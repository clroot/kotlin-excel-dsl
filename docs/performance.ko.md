# 성능

[English](performance.md)

라이브러리는 Apache POI의 SXSSF (Streaming Usermodel API)를 사용하여 메모리 효율적인 대용량 데이터 처리를 지원합니다.

## 벤치마크

**테스트 환경**: MacBook Pro 14" M3 Pro (JMH 벤치마크, Sequence 기반 지연 데이터 생성)

| 행 수 | 시간 | 피크 메모리 (min) | 피크 메모리 (avg) | 피크 메모리 (max) |
|-------|------|-------------------|-------------------|-------------------|
| 100,000 | ~432ms | ~34 MB | ~106 MB | ~189 MB |
| 500,000 | ~1.8초 | ~42 MB | ~133 MB | ~193 MB |
| 1,000,000 | ~3.5초 | ~59 MB | ~136 MB | ~193 MB |

## 주요 특징

### 진정한 스트리밍

전체 데이터셋을 메모리에 로드하지 않고 행 단위로 처리합니다. Apache POI의 SXSSF API를 통해 설정 가능한 행 윈도우만 메모리에 유지합니다.

```kotlin
// 수백만 행이어도 메모리 사용량이 일정하게 유지됨
excel {
    sheet<LargeData>("Data") {
        column("ID") { it.id }
        column("Value") { it.value }
        rows(largeDataSequence)  // Sequence는 지연 처리됨
    }
}.writeTo(output)
```

### O(1) 메모리 Auto-width

컬럼 너비 계산 시 모든 셀 값을 저장하지 않고 최대 너비만 추적합니다. 이를 통해 대용량 데이터셋에서도 auto-width가 메모리 병목이 되지 않습니다.

### 준-일정한 메모리

SXSSF 스트리밍 덕분에 행 수가 10배 증가해도 피크 메모리는 ~1.7배(min 기준)만 증가합니다. 메모리 증가는 주로 POI의 내부 버퍼링에서 발생하며, 데이터 저장에서는 발생하지 않습니다.

## 설정

기본 행 접근 윈도우 크기는 100행입니다. 필요한 경우 `PoiRenderer` 생성자를 통해 조정할 수 있지만, 대부분의 경우 기본값으로 충분합니다.

## 모범 사례

1. **대용량 데이터에 Sequence 사용**: `rows()`에 `List<T>` 대신 `Sequence<T>`를 전달하여 지연 평가를 활용하세요.

2. **모든 데이터를 메모리에 로드하지 않기**: 데이터베이스나 파일 소스에서 직접 스트리밍하세요.

3. **고정 컬럼 너비 고려**: 매우 대용량 데이터셋의 경우, auto-width보다 고정 너비(`width = 20.chars`)가 약간 더 효율적입니다.
